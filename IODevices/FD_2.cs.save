using System;
using System.Collections.Generic;
//using System.Linq;
using System.Text;

using System.IO;
using System.Threading;

namespace Memulator
{
    class FD_2 : IODevice
    {
        /*
         *  this is the code from the FD2 driver from GINIX (should be the same for DWTPC) to calculate
         *  the Track and sector to use in the controller based on the LSN passed in B/X (msb in B and LSBs in X)
         *  
        **************************************************************
        00477                   *
        00478                   * Convert Logical Sector Number
        00479                   * To Physical Track And Sector
        00480                   *
        00481                   *  Input:  B = Msb Of Logical Sector Number
        00482                   *          X = Lsb'S Of Logical Sector Number
        00483                   *  Output: A = Physical Track Number
        00484                   *          Sector Reg = Physical Sector Number
        00485                   *  Error:  Carry Set & B = Error Code
        00486                   *
        00487   0251 5D         PHYSIC   tstb             CHECK Sector bounds 
        00488   0252 2659                bne   PHYERR     msb must be zero 
        00489   0254 1F10                tfr   X,D        Logical sector (os-9) 
        00490   0256 10830000            cmpd  #0         Logical sector zero? 
        00491   025A 274B                beq   PHYSC7     ..yes; skip conversion. 
        00492   025C AEC900A7            ldx   CURTBL,U 
        00493   0260 10A301              cmpd  DD.TOT+1,X Too high sector number? 
        00494   0263 2448                bhs   PHYERR     ..yes; sorry 
        00495   0265 83000A              subd  #10        subtract 10 sectors 
        00496   0268 2405                bcc   PHYSC1 
        00497   026A C3000A              addd  #10 
        00498   026D 2038                bra   PHYSC7 
        00499   026F E7C900B6   PHYSC1   stb   V.TMP,U    Save (B) 
        00500   0273 5F                  clrb 
        00501   0274 3404                pshs  b          Will Be Track Number 
        00502   0276 E68810              ldb   DD.FMT,x 
        00503   0279 54                  lsrb             Shift Side Bit To Carry 
        00504   027A E6C900B6            ldb   V.TMP,U    Restore (B) 
        00505   027E 2410                bcc   PHYSC4     Branch If Single Sided 
        00506                   
        00507                   * DOUBLE SIDED TRACK/SECTOR CALCULATIONS
        00508                   
        00509   0280 63C900B5   PHYSC2   com   V.SIDE,U   Switch Sides 
        00510   0284 2602                bne   PHYSC3     Don't inc Track for Side 1 to 2 Switch 
        00511   0286 6CE4                inc   0,s        Increment Track 
        00512   0288 E003       PHYSC3   subb  DD.TKS,X   Subtrack One Track Of Sectors 
        00513   028A 8200                sbca  #0 
        00514   028C 24F2                bcc   PHYSC2     Continue Until Less than One Track of Sectors 
        00515   028E 2008                bra   PHYSC5     Exit and Clean Up 
        00516                   
        00517                   * SINGLE SIDED TRACK/SECTOR CALCULATIONS
        00518                   
        00519   0290 6CE4       PHYSC4   inc   0,s        Increment Track Count 
        00520   0292 E003                subb  DD.TKS,X   Subtrack One Track Of Sectors 
        00521   0294 8200                sbca  #0 
        00522   0296 24F8                bcc   PHYSC4     Continue Until Less Than One Track Left 
        00523                   
        00524                   * SET DENSITY,PUT SECTOR IN SECTOR REGISTER, TRACK IN A
        00525                   
        00526   0298 A68810     PHYSC5   lda   DD.FMT,X 
        00527   029B 8402                anda  #2         Double Density? 
        00528   029D 2704                beq   PHYSC6     No 
        00529   029F A7C900BB            sta   V.DDEN,U   Set Double Density Flag 
        00530   02A3 3502       PHYSC6   puls  a          Get Track 
        00531   02A5 EB03                addb  DD.TKS,X   Add Back For Sector Number 
        00532   02A7 E7D900B0   PHYSC7   stb   [V.SECR,U] Put Sector (B) In Sector Register 
        00533   02AB 5F                  clrb             Clear Carry; A=Track 
        00534   02AC 39         RETRN2   rts 
        00535                   
        00536                   
        00537   02AD 53         PHYERR   comb 
        00538   02AE C6F1                ldb   #E$SECT    Error: bad sector number 
        00539   02B0 39                  rts 
        00540                            pag 
         */

        bool _spin = false;

        //#define RD_FLOPPY       0
        //#define WT_FLOPPY       1
        //
        //#define FDC_DRVREG    0x8014        //  Which Drive is selected
        //#define FDC_STATREG   0x8018        //      READ
        //                                    //  0x01 = BUSY
        //                                    //  0x02 = DRQ
        //                                    //  0x04 = 
        //                                    //  0x08 = 
        //                                    //  0x10 = 
        //#define FDC_CMDREG    0x8018        //      WRITE
        //                                    //  0x0X = RESTORE
        //                                    //  0x1X = SEEK
        //                                    //  0x2X = STEP
        //                                    //  0x3X = STEP     W/TRACK UPDATE
        //                                    //  0x4X = STEP IN
        //                                    //  0x5X = STEP IN  W/TRACK UPDATE
        //                                    //  0x6X = STEP OUT
        //                                    //  0x7X = STEP OUT W/TRACK UPDATE
        //                                    //  0x8X = READ  SINGLE   SECTOR
        //                                    //  0x9X = READ  MULTIPLE SECTORS
        //                                    //  0xAX = WRITE SINGLE   SECTOR
        //                                    //  0xBX = WRITE MULTIPLE SECTORS
        //                                    //  0xCX = READ ADDRESS
        //                                    //  0xDX = FORCE INTERRUPT
        //                                    //  0xEX = READ TRACK
        //                                    //  0xFX = WRITE TRACK
        //
        //#define FDC_TRKREG    0x8019        //  Track Register
        //#define FDC_SECREG    0x801A        //  Sector Register
        //#define FDC_DATAREG   0x801B        //  Data Register

        private int FDC_BUSY            = 0x01;
        private int FDC_DRQ             = 0x02;
        private int FDC_TRKZ            = 0x04;
        private int FDC_CRCERR          = 0x08;
        private int FDC_SEEKERR         = 0x10;
        private int FDC_RNF             = 0x10;
        private int FDC_HDLOADED        = 0x20;
        private int FDC_WRTPROTECT      = 0x40;
        private int FDC_NOTREADY        = 0x80;

        private int DRV_DRQ             = 0x80;

        enum FDCRegisterOffsets
        {
            FDC_DRVREG_OFFSET   = 0,
            FDC_STATREG_OFFSET  = 4,
            FDC_CMDREG_OFFSET   = 4,
            FDC_TRKREG_OFFSET   = 5,
            FDC_SECREG_OFFSET   = 6,
            FDC_DATAREG_OFFSET  = 7
        }

        private int             m_statusReadsWithoutDataRegisterAccess;
        private int             m_nRow;
        //private volatile bool   m_nAbort = false;
        private int             m_nCurrentSideSelected = 0;

        private bool            m_nFDCWriting  = false;
        private bool            m_nFDCReading  = false;
        private int             m_nFDCReadPtr  = 0;
        private int             m_nFDCWritePtr = 0;


        private int             m_nFDCTrack;
        private int             m_nFDCSector;
        private long            m_lFileOffset;

        private int             m_nBytesToTransfer;
        //private int             m_nStatusReads;

        private byte []         m_caReadBuffer  = new byte [65536];
        private byte []         m_caWriteBuffer = new byte [65536];

        private byte            m_FDC_DRVRegister;
        private byte            m_FDC_STATRegister;
        private byte            m_FDC_CMDRegister;
        private byte            m_FDC_TRKRegister;
        private byte            m_FDC_SECRegister;
        private byte            m_FDC_DATARegister;

        private bool ImageIsOrthogonal (int nDrive)
        {
            // check image to see if the sectors between sector 0x0a and sectors per track - 1 (inclusive) have been padded and the same
            // number of sectors have been removed from the end.

            // default his to true since we orginally did this to the OS9 diskette images that we created from real diskettes.

            bool imageIsOrthogonal = true;

            if (Program.FloppyDriveStream[nDrive] != null && nDrive != 0)
            {
                long currentPosition = Program.FloppyDriveStream[nDrive].Position;

                byte[] rootDirectoryFileDescriptorLSN = new byte[3];
                Program.FloppyDriveStream[nDrive].Seek(8, SeekOrigin.Begin);                                        // offset in SIR to root directory file descriptor
                Program.FloppyDriveStream[nDrive].Read(rootDirectoryFileDescriptorLSN, 0, 3);                       // 24 bit LSN

                long offsetToRootDirectoryFileDescriptor = ((rootDirectoryFileDescriptorLSN[0] * 256 * 256) + (rootDirectoryFileDescriptorLSN[1] * 256) + rootDirectoryFileDescriptorLSN[2]) * 256;

                byte [] rootDirectoryDataLSN = new byte[3];
                Program.FloppyDriveStream[nDrive].Seek(offsetToRootDirectoryFileDescriptor + 16, SeekOrigin.Begin); // offset in File Descriptor to root directory file data
                Program.FloppyDriveStream[nDrive].Read(rootDirectoryDataLSN, 0, 3);                                 // 24 bit LSN

                long offsetToRootDirectoryDataLSN = ((rootDirectoryDataLSN[0] * 256 * 256) + (rootDirectoryDataLSN[1] * 256) + rootDirectoryDataLSN[2]) * 256;

                byte[] firstDirectoryInRootLSN = new byte[3];
                Program.FloppyDriveStream[nDrive].Seek(offsetToRootDirectoryDataLSN + 64 + 29, SeekOrigin.Begin);   // offset in directory data to first root directory entries file descriptor LSN
                Program.FloppyDriveStream[nDrive].Read(firstDirectoryInRootLSN, 0, 3);                              // 24 bit LSN

                long offsetToFirstDirectoryInRootFileDescriptorLSN = ((firstDirectoryInRootLSN[0] * 256 * 256) + (firstDirectoryInRootLSN[1] * 256) + firstDirectoryInRootLSN[2]) * 256;

                byte[] firstDirectoryInRootDataLSN = new byte[3];
                Program.FloppyDriveStream[nDrive].Seek(offsetToFirstDirectoryInRootFileDescriptorLSN + 16, SeekOrigin.Begin);   // offset in directory data to first root directory entries file descriptor LSN
                Program.FloppyDriveStream[nDrive].Read(firstDirectoryInRootDataLSN, 0, 3);                                     // 24 bit LSN

                long offsetToFirstDirectoryInRootDataLSN = ((firstDirectoryInRootDataLSN[0] * 256 * 256) + (firstDirectoryInRootDataLSN[1] * 256) + firstDirectoryInRootDataLSN[2]) * 256;

                // make sure we are pointing to a sector that is within the image
                if (offsetToFirstDirectoryInRootDataLSN < Program.FloppyDriveStream[nDrive].Length)
                {
                    byte[] firstDirEntry  = new byte[2];
                    Program.FloppyDriveStream[nDrive].Seek(offsetToFirstDirectoryInRootDataLSN, SeekOrigin.Begin);
                    Program.FloppyDriveStream[nDrive].Read(firstDirEntry, 0, 2);                                    // should be 0x2E 0xAE

                    byte[] secondDirEntry = new byte[1];
                    Program.FloppyDriveStream[nDrive].Seek(offsetToFirstDirectoryInRootDataLSN + 32, SeekOrigin.Begin);
                    Program.FloppyDriveStream[nDrive].Read(secondDirEntry, 0, 1);                                    // should be 0xAE

                    if (firstDirEntry[0] == 0x2E && firstDirEntry[1] == 0xAE && secondDirEntry[0] == 0xAE)
                    {
                        // Weare pointing at a valid root directory

                        imageIsOrthogonal = false;
                    }
                }

                Program.FloppyDriveStream[nDrive].Seek(currentPosition, SeekOrigin.Begin);
            }

            //return true;

            return imageIsOrthogonal;
        }

        void CalcOS9FileOffset(int nDrive, int nSectorSize)
        {
            int nSPT = Program.SectorsPerTrack[nDrive];
            int nFormat = Program.FormatByte[nDrive];

            //  OS9 ALWAYS has m_nSectorsOnTrackZero sectors on track 0 side 0 and uses the side select before seeking to another cylinder.
            //  track 0 side 1 has m_nSectorsPerTrack sectors.
            //
            //  09/02/2020 MDE
            //
            //  Added ability to specify in the FD2 configuration whether of not the OS9 FD2 driver is hard coded for 10 sectors on
            //  track 0 side 0. New parameter in the config file called 

            if (m_nFDCTrack == 0)
            {
                // if we are on track 0 then the offset is always the sector number  times the sector size - no adjustment required

                m_lFileOffset = (long)(m_nFDCSector) * (long)nSectorSize;
            }
            else
            {
                // start off with track 0 side 1 already added in if it's double sided. 
                // We'll get to track 0 side 0 sectors later

                if ((nFormat & 0x0001) != 0)   // double sided
                {
                    m_lFileOffset = (long)nSPT * (long)nSectorSize;

                    // is this is not side 0, add in this tracks side 0 sectors

                    if (m_nCurrentSideSelected != 0)
                        m_lFileOffset += (long)nSPT * (long)nSectorSize;

                    // the rest of the math is done on cylinders

                    nSPT *= 2;
                }
                else
                    m_lFileOffset = 0L;

                // now add in all of the previous tracks sectors (except track 0)

                m_lFileOffset += (long)(((m_nFDCTrack - 1) * nSPT) + m_nFDCSector) * (long)nSectorSize;
            }

            // if not track 0 side 0 - add in track 0 side 0 sectors because it may have a different number of sectors

            if (!((m_nFDCTrack == 0) && (m_nCurrentSideSelected == 0)))
            {

                m_lFileOffset += (long)Program.SectorsOnTrackZero[nDrive] * (long)nSectorSize;
            }
        }

        public void CalcFileOffset (int nDrive)
        {
            LogActivity(1, string.Format("CalcFileOffsetCalled on drive {0}\n", nDrive.ToString("D1")));

            int nRow = -1;
            int nSectorsOnTrack0Side0ForOS9 = 10;

            foreach (BoardInfoClass bi in Program.BoardInfo)
            {
                if (bi != null)
                {
                    if (bi.cDeviceType == (int)Devices.DEVICE_FDC)
                    {
                        nRow = bi.nBoardId;
                        break;
                    }
                }
                else
                    break;
            }
            if (nRow >= 0)
                nSectorsOnTrack0Side0ForOS9 = Program.BoardInfo[nRow].nSectorsOnTrack0Side0ForOS9;

            if ((m_nFDCTrack == 0) && (m_nFDCSector == 0) && (m_nCurrentSideSelected == 0))
                m_lFileOffset = 0L;
            else
            {
                if (Program.DiskFormat[nDrive] == DiskFormats.DISK_FORMAT_MF_FDOS)
                {
                    LogActivity(1, "  Diskette format = DISK_FORMAT_MF_FDOS\n");
                    m_lFileOffset = (long) ((m_nFDCTrack * Program.SectorsPerTrack[nDrive]) + (m_nFDCSector - 1)) * 128L;
                }
                else if ((Program.DiskFormat[nDrive] == DiskFormats.DISK_FORMAT_FLEX) || (Program.DiskFormat[nDrive] == DiskFormats.DISK_FORMAT_UNIFLEX))
                {
                    LogActivity(1, "  Diskette format = DISK_FORMAT_FLEX or DISK_FORMAT_UNIFLEX\n");
                    m_lFileOffset = (long) ((m_nFDCTrack * Program.SectorsPerTrack[nDrive]) + (m_nFDCSector - 1)) * 256L;
                }
                else if (Program.DiskFormat[nDrive] == DiskFormats.DISK_FORMAT_FLEX_IMA)
                {
                    if (m_nFDCTrack == 0)
                    {
                        // these are ALWAYS single density sectors for IMA format

                        m_lFileOffset = (long)((m_nFDCSector - 1) * 256);
                    }
                    else
                    {
                        // if this image is  formatted as an IMA image, then track zero will have
                        // either 10 or 20 sectors depending on whether it is single or double
                        // sided. We can tell if it is single or double sided if the maximum
                        // number of sectors is > 1
                        //
                        //  valid IMA formats:
                        //
                        //  tracks      sides   density     sectors/track   filesize                    blank filename
                        //  --------    -----   -------     -------------   --------------------------  --------------
                        //  35          1       single      10              35 * 1 * 10 * 256 =  89600  SSSD35T.IMA
                        //  35          2       single      20              35 * 2 * 10 * 256 = 179200  DSSD35T.IMA
                        //  35          1       double      18       2560 + 34 * 1 * 18 * 256 = 159232  SSDD35T.IMA
                        //  35          2       double      36       5120 + 34 * 2 * 18 * 256 = 318464  DSDD35T.IMA
                        //  40          1       single      10              40 * 1 * 10 * 256 = 102400  SSSD40T.IMA
                        //  40          2       single      20              40 * 2 * 10 * 256 = 204800  DSSD40T.IMA <-
                        //  40          1       double      18       2560 + 39 * 1 * 18 * 256 = 182272  SSDD40T.IMA
                        //  40          2       double      36       5120 + 39 * 2 * 18 * 256 = 364544  DSDD40T.IMA
                        //  80          1       single      10              80 * 1 * 10 * 256 = 204800  SSSD80T.IMA <-
                        //  80          2       single      20              80 * 2 * 10 * 256 = 409600  DSSD80T.IMA
                        //  80          1       double      18       2560 + 79 * 1 * 18 * 256 = 366592  SSDD80T.IMA
                        //  80          2       double      36       5120 + 79 * 2 * 18 * 256 = 733184  DSDD80T.IMA
                        //
                        //      Since these are the only valid IMA formats - we can assume double sided if the max sectors for
                        //  this images is > 18 (because sectors are 1 based not 0)
                        //
                        //  80 track single sides single density is the same size as 40 track double sided single density. The 
                        //  only way to tell the difference is by the max sectors per track. If it's 10 - this is single sided
                        //  single density 80 track otherwise it is double single density sided 40 track

                        int sectorBias = 1;
                        switch (Program.SectorsPerTrack[nDrive])
                        {
                            // these are the only valid max sector values for IMA (10 or 18 = single side, 20 or 36 = double sided)

                            case 10:
                                m_lFileOffset = ((((m_nFDCTrack - 1) * (Program.SectorsPerTrack[nDrive])) + (m_nFDCSector - sectorBias)) * 256) + (256 * 10);
                                break;
                            case 20:
                                m_lFileOffset = ((((m_nFDCTrack - 1) * (Program.SectorsPerTrack[nDrive])) + (m_nFDCSector - sectorBias)) * 256) + (256 * 20);
                                break;
                            case 18:
                                m_lFileOffset = ((((m_nFDCTrack - 1) * (Program.SectorsPerTrack[nDrive])) + (m_nFDCSector - sectorBias)) * 256) + (256 * 10);
                                break;
                            case 36:
                                m_lFileOffset = ((((m_nFDCTrack - 1) * (Program.SectorsPerTrack[nDrive])) + (m_nFDCSector - sectorBias)) * 256) + (256 * 20);
                                break;
                        }
                    }
                }
                else
                {
                    CalcOS9FileOffset(nDrive, 256);
                    #region OLDWAY
                    ////if (nDrive == 1)
                    ////{
                    ////    int x = 1;
                    ////}

                    //int nSPT    = Program.SectorsPerTrack[nDrive];
                    //int nFormat = Program.FormatByte[nDrive];

                    //LogActivity(1, string.Format("  Diskette format = DISK_FORMAT_OS9 - nSPT = 0x{0}, nFormat = 0x{1}\n", nSPT.ToString("X2"), nFormat.ToString("X2")));

                    ////  OS9 ALWAYS has m_nSectorsOnTrackZero sectors on track 0 side 0 and uses the side select before seeking to another cylinder.
                    ////  track 0 side 1 has m_nSectorsPerTrack sectors.

                    //LogActivity(1, string.Format("    Track 0x{0} Sector 0x{1} ", m_nFDCTrack.ToString("X2"), m_nFDCSector.ToString("X2")));

                    //if (m_nFDCTrack == 0)
                    //{
                    //    m_lFileOffset = (long)(m_nFDCSector) * 256L;
                    //    LogActivity(1, string.Format("      Setting offset = 0x{0} ((long)(m_nFDCSector) * 256L)\n", m_lFileOffset.ToString("X8")));
                    //}
                    //else
                    //{
                    //    // start off with track 0 side 1 already added in if it's double sided. 
                    //    // We'll get to track 0 side 0 sectors later

                    //    if ((nFormat & 0x0001) != 0)   // double sided
                    //    {
                    //        m_lFileOffset = (long)nSPT * 256L;
                    //        LogActivity(1, string.Format("      This disk is double sided - Setting initial offset = 0x{0} (offset = (long)nSPT * 256L)\n", m_lFileOffset.ToString("X8")));

                    //        // is this is not side 0, add in this tracks side 0 sectors

                    //        if (m_nCurrentSideSelected != 0)
                    //        {
                    //            m_lFileOffset += (long)nSPT * 256L;
                    //            LogActivity(1, string.Format("      This is not side 0 - Setting initial offset = 0x{0} (offset += (long)nSPT * 256L)\n", m_lFileOffset.ToString("X8")));
                    //        }

                    //        // the rest of the math is done on cylinders

                    //        nSPT *= 2;
                    //        LogActivity(1, string.Format("      Now setting nSPT = 0x{0} (nSPT *= 2)\n", nSPT.ToString("X2")));
                    //    }
                    //    else
                    //    {
                    //        m_lFileOffset = 0L;
                    //        LogActivity(1, string.Format("      This disk is single sided - Setting initial offset = 0x0000 (offset = 0L)\n", m_lFileOffset.ToString("X8")));
                    //    }

                    //    // now add in all of the previous tracks sectors (except track 0)

                    //    m_lFileOffset += (long)(((m_nFDCTrack - 1) * nSPT) + m_nFDCSector) * 256L;
                    //    LogActivity(1, string.Format("      Now add in all of the prefious calculations offset = 0x{0} (offset += (long)(((m_nFDCTrack - 1) * nSPT) + m_nFDCSector) * 256L)\n", m_lFileOffset.ToString("X8")));
                    //}

                    //// if not track 0 side 0 - add in track 0 side 0 sectors 
                    //// because it may have a different number of sectors

                    //if (!((m_nFDCTrack == 0) && (m_nCurrentSideSelected == 0)))
                    //{
                    //    m_lFileOffset += (long) Program.SectorsOnTrackZero[nDrive] * 256L;
                    //    LogActivity(1, string.Format("      Take care of not being track 0 side 0 - offset = 0x{0} (offset += (long) Program.SectorsOnTrackZero[nDrive] * 256L)\n\n", m_lFileOffset.ToString("X8")));
                    //}

                    //// Let's see if this diskette is orthoganal or not. If the file size is evenly divisable by the number of sectors then it is orthoganal,
                    //// otherwise, we need to subtract the modulus difference * sector size from the final result.

                    //// The diskette image EmuOS9Boot.DSK has had the sectors between 0x0A and 0x1200 padded to make it orthogonal. It then had to have the same number
                    //// of sectors removed from the end of the file to keep the file size = number of LSN's * sectorsize (256 bytes).

                    //long fileSize = Program.FloppyDriveStream[nDrive].Length;
                    //long sectorsOnTrackZero = (fileSize % (Program.SectorsPerTrack[nDrive] * 256)) / 256L;

                    //// if the image has not been padded after LSN 0x09 (10 sectors on track 0 side 0), we need to adjust

                    //if (!ImageIsOrthogonal(nDrive) && nDrive != 0)
                    //{
                    //    if (sectorsOnTrackZero != 0)
                    //    {
                    //        // the diskette image is not orthoganal - adjustment needed

                    //        m_lFileOffset -= (long)sectorsOnTrackZero * 256L;
                    //    }
                    //}
                    #endregion
                }
            }
        }

        public override void Write (ushort m, byte b)
        {
            int nDrive         = m_FDC_DRVRegister & 0x03;
            int nType          = 1;
            int nWhichRegister = m - m_sBaseAddress;
            bool bMultisector;

            switch (nWhichRegister)
            {
                case (int)FDCRegisterOffsets.FDC_DATAREG_OFFSET:
                    m_FDC_DATARegister = b;
                    if (((m_FDC_STATRegister & FDC_BUSY) == FDC_BUSY) && m_nFDCWriting)
                    {
                        m_caWriteBuffer[m_nFDCWritePtr++] = b;
                        if (m_nFDCWritePtr == m_nBytesToTransfer)
                        {
                            // Here is where we will seek and write dsk file

                            CalcFileOffset (nDrive);

                            if (Program.FloppyDriveStream[nDrive] != null)
                            {
                                Program.FloppyDriveStream[nDrive].Seek (m_lFileOffset, SeekOrigin.Begin);
                                Program.FloppyDriveStream[nDrive].Write (m_caWriteBuffer, 0, m_nBytesToTransfer);
                                Program.FloppyDriveStream[nDrive].Flush ();
                            }

                            //Program.pStaticFloppyActivityLight[nDrive]->SetBitmap (Program.m_hGreyDot);

                            m_FDC_STATRegister &= (byte)~(FDC_DRQ | FDC_BUSY);
                            m_FDC_DRVRegister &= (byte)~DRV_DRQ;        // turn off high order bit in drive status register
                            m_nFDCWriting = false;

                            ClearInterrupt ();
                        }
                        else
                        {
                            m_FDC_STATRegister |= (byte)FDC_DRQ;
                            m_FDC_DRVRegister  |= (byte)DRV_DRQ;

                            if (_bInterruptEnabled)
                            {
                                SetInterrupt (_spin);
                                if (Program._cpu != null)
                                {
                                    if ((Program._cpu.InWait || Program._cpu.InSync) && Program._cpuThread.ThreadState == ThreadState.Suspended)
                                    {
                                        try
                                        {
                                            Program._cpuThread.Resume();
                                        }
                                        catch (ThreadStateException e)
                                        {
                                            // do nothing if thread is not suspended
                                        }
                                    }
                                }
                            }
                        }
                    }
                    break;
                case (int)FDCRegisterOffsets.FDC_DRVREG_OFFSET:
                    if ((b & 0x40) == 0x40)         // we are selecting side 1
                        m_nCurrentSideSelected = 1;
                    else                            // we are selecting side 0
                        m_nCurrentSideSelected = 0;

                    m_FDC_DRVRegister = b;
                    break;
                case (int)FDCRegisterOffsets.FDC_CMDREG_OFFSET:
                    m_nFDCReading = m_nFDCWriting = false;      // can't be read/writing if commanding
                    m_statusReadsWithoutDataRegisterAccess = 0;

                    switch (b & 0xF0)
                    {
                        // TYPE I

                        case 0x00:  //  0x0X = RESTORE
                            m_nFDCTrack = 0;
		                    m_FDC_TRKRegister = 0;
                            break;

                        case 0x10:  //  0x1X = SEEK
                            m_nFDCTrack = m_FDC_DATARegister;
                            m_FDC_TRKRegister =(byte) m_nFDCTrack;
                            break;

                        case 0x20:  //  0x2X = STEP
                            break;

                        case 0x30:  //  0x3X = STEP     W/TRACK UPDATE
                            break;

                        case 0x40:  //  0x4X = STEP IN
                            if (m_nFDCTrack < 79)
                                m_nFDCTrack++;
                            break;
                        case 0x50:  //  0x5X = STEP IN  W/TRACK UPDATE
                            if (m_nFDCTrack < 79)
                            {
                                m_nFDCTrack++;
                                m_FDC_TRKRegister = (byte) m_nFDCTrack;
                            }
                            break;
                        case 0x60:  //  0x6X = STEP OUT
                            if (m_nFDCTrack > 0)
                                --m_nFDCTrack;
                            break;
                        case 0x70:  //  0x7X = STEP OUT W/TRACK UPDATE
                            if (m_nFDCTrack > 0)
                            {
                                --m_nFDCTrack;
                                m_FDC_TRKRegister = (byte)m_nFDCTrack;
                            }
                            break;

                            // TYPE II

                        case 0x80:  //  0x8X = READ  SINGLE   SECTOR
                        case 0x90:  //  0x9X = READ  MULTIPLE SECTORS
                        case 0xA0:  //  0xAX = WRITE SINGLE   SECTOR
                        case 0xB0:  //  0xBX = WRITE MULTIPLE SECTORS

                            m_FDC_STATRegister |= (byte)FDC_HDLOADED;

                            nType = 2;
				            m_nFDCTrack = m_FDC_TRKRegister;

                            bMultisector = false;
                            m_nBytesToTransfer = 256;

                            if ((b & 0x10) == 0x10)
                            {
                                if (Program.AllowMultiSectorTransfers)
                                {
                                    bMultisector = true;
                                    m_nBytesToTransfer = (Program.SectorsPerTrack[nDrive] - m_nFDCSector) * 256;
                                }
                            }

                            if ((b & 0x20) == 0x20)   // WRITE
                            {
                                //Program.pStaticFloppyActivityLight[nDrive]->SetBitmap (Program.m_hRedDot);

                                m_nFDCReading = false;
                                m_nFDCWriting = true;
                                m_nFDCWritePtr = 0;
                                m_statusReadsWithoutDataRegisterAccess = 0;
                                //m_nStatusReads = 0;
                            }
                            else                    // READ
                            {
                                //Program.pStaticFloppyActivityLight[nDrive]->SetBitmap (Program.m_hGreenDot);

                                m_nFDCReading = true;
                                m_nFDCWriting = false;
                                m_nFDCReadPtr = 0;
                                m_statusReadsWithoutDataRegisterAccess = 0;
                                //m_nStatusReads = 0;

                                CalcFileOffset (nDrive);

                                if (Program.FloppyDriveStream[nDrive] != null)
                                {
                                    Program.FloppyDriveStream[nDrive].Seek (m_lFileOffset, SeekOrigin.Begin);
                                    Program.FloppyDriveStream[nDrive].Read (m_caReadBuffer, 0, m_nBytesToTransfer);

                                    m_FDC_DATARegister = m_caReadBuffer[0];
                                }
                            }
                            break;

                            // TYPE III

                        case 0xC0:  //  0xCX = READ ADDRESS
                            nType = 3;
                            break;
                        case 0xE0:  //  0xEX = READ TRACK
                            nType = 3;
                            break;
                        case 0xF0:  //  0xFX = WRITE TRACK
                            nType = 3;
                            break;

                            // TYPE IV

                        case 0xD0:  //  0xDX = FORCE INTERRUPT
                            nType = 4;
                            break;
                    }

                    //  since this may get set as a result of issuing a read command without actually 
                    //  reading anything - just waiting for the controller to go not busy to do a CRC 
                    //  check of the sector only, we need some way to make sure this status gets cleared
                    //  after some time. Lets try by counting the number of times the status is checked
                    //  without a data read and after 256 status reads withiout a data read - we will 
                    //  set the status to not busy.
                    
                    m_FDC_STATRegister = (byte)FDC_BUSY;
                    m_statusReadsWithoutDataRegisterAccess = 0;
                    //m_nStatusReads = 0;

                    // see if current drive is READY

                    if (Program.DriveOpen[nDrive] == true)
                        m_FDC_STATRegister |= (byte)FDC_NOTREADY;
                    else
                        m_FDC_STATRegister &= (byte)~FDC_NOTREADY;

                    switch (nType)
                    {
                        case 1:
                            m_FDC_STATRegister |= (byte)FDC_HDLOADED;
                            if (m_nFDCTrack == 0)
                                m_FDC_STATRegister |= (byte)FDC_TRKZ;
                            else
                                m_FDC_STATRegister &= (byte)~FDC_TRKZ;
                            break;

                        case 2:
                        case 3:
                            if (Program.FloppyDriveStream[nDrive] != null)
                            {
                                m_FDC_STATRegister |= (byte)FDC_DRQ;
                                m_FDC_DRVRegister |= (byte)DRV_DRQ;

                                if (_bInterruptEnabled)
                                {
                                    SetInterrupt (_spin);
                                    if (Program._cpu != null)
                                    {
                                        if ((Program._cpu.InWait || Program._cpu.InSync) && Program._cpuThread.ThreadState == ThreadState.Suspended)
                                        {
                                            try
                                            {
                                                Program._cpuThread.Resume();
                                            }
                                            catch (ThreadStateException e)
                                            {
                                                // do nothing if thread is not suspended
                                            }
                                        }
                                    }
                                }
                            }
                            else
                            {
                                m_FDC_STATRegister &= (byte)~FDC_DRQ;
                                m_FDC_DRVRegister &= (byte)~DRV_DRQ;
                            }
                            break;

                        case 4:
                            m_FDC_STATRegister &= (byte)~(
                                                        FDC_DRQ     |   // clear Data Request Bit
                                                        FDC_SEEKERR |   // clear SEEK Error Bit
                                                        FDC_CRCERR  |   // clear CRC Error Bit
                                                        FDC_RNF     |   // clear Record Not Found Bit
                                                        FDC_BUSY        // clear BUSY bit
                                                      );
                            m_FDC_DRVRegister  &= (byte)~DRV_DRQ;        // turn off high order bit in drive status register
                            break;
                    }
                    break;
                case (int)FDCRegisterOffsets.FDC_TRKREG_OFFSET:
                    m_FDC_TRKRegister = b;
                    m_nFDCTrack = b;
                    break;
                case (int)FDCRegisterOffsets.FDC_SECREG_OFFSET:
                    m_FDC_SECRegister = b;
                    m_nFDCSector = b;
                    break;

                default:
                    Program._cpu.WriteToFirst64K (m, b);
                    break;
            }
        }

        public override byte Read(ushort m)
        {
            LogActivity(4, string.Format("Read called on address = 0x{0}, ", m.ToString("X4")));

            byte d;
            int nWhichRegister = m - m_sBaseAddress;
            int nDrive         = m_FDC_DRVRegister & 0x03;           // get active drive

            switch (nWhichRegister)
            {
                case (int)FDCRegisterOffsets.FDC_DATAREG_OFFSET:
                    if (m_nFDCReading)
                    {
                        // only send this message at the start
                        if (m_nFDCReadPtr == 0)
                            LogActivity(4, "    register = FDC_DATAREG_OFFSET (reading data)\n");

                        m_statusReadsWithoutDataRegisterAccess = 0;
                        //m_nStatusReads = 0;
                        m_FDC_DATARegister = m_caReadBuffer[m_nFDCReadPtr++];
                        if (m_nFDCReadPtr == m_nBytesToTransfer)
                        {
                            LogActivity(4, string.Format("               finished reading data - bytes read = {0}\n", m_nFDCReadPtr));

                            m_FDC_STATRegister &= (byte)~(FDC_DRQ | FDC_BUSY);
                            LogActivity(4, "    Status register set to turn off high order bit in controller status register and busy flag\n");

                            m_FDC_DRVRegister &= (byte)~DRV_DRQ;            // turn off high order bit in drive status register
                            LogActivity(4, "    Status register set to turn off high order bit in drive status register\n");

                            m_nFDCReading = false;
                            LogActivity(4, "    Reading set to false\n");

                            //Program.pStaticFloppyActivityLight[nDrive]->SetBitmap (Program.m_hGreyDot);

                            ClearInterrupt ();
                            LogActivity(4, "    Interrupt has been cleared\n");
                        }
                        // --------------------
                        else
                        {
                            LogActivity(4, string.Format("               still reading data - bytes read = {0} - setting stat and drive DRQ to true\n", m_nFDCReadPtr));

                            m_FDC_STATRegister |= (byte)DRV_DRQ;
                            m_FDC_DRVRegister |= (byte)DRV_DRQ;
                            if (_bInterruptEnabled)
                            {
                                SetInterrupt(_spin);
                                if (Program._cpu != null)
                                {
                                    if ((Program._cpu.InWait || Program._cpu.InSync) && Program._cpuThread.ThreadState == ThreadState.Suspended)
                                    {
                                        try
                                        {
                                            Program._cpuThread.Resume();
                                        }
                                        catch (ThreadStateException e)
                                        {
                                            // do nothing if thread is not suspended
                                        }
                                    }
                                }
                            }
                        } 
                        // --------------------
                        d = m_FDC_DATARegister;
                    }
		            else
                    {
                        d = m_FDC_DATARegister;
                    }
                    break;
                case (int)FDCRegisterOffsets.FDC_STATREG_OFFSET:

                    LogActivity(4, "    register = FDC_STATREG_OFFSET\n");

                    m_statusReadsWithoutDataRegisterAccess++;

                    if (Program.DriveOpen[nDrive] == true)               // see if current drive is READY
                        m_FDC_STATRegister |= (byte)FDC_NOTREADY;
                    else
                        m_FDC_STATRegister &= (byte)~FDC_NOTREADY;

                    if (Program.WriteProtected[nDrive] == true)          // see if write protected
                        m_FDC_STATRegister |= (byte)FDC_WRTPROTECT;
                    else
                        m_FDC_STATRegister &= (byte)~FDC_WRTPROTECT;

		            if (!m_nFDCReading && !m_nFDCWriting)           // turn off BUSY if not read/writing
                        m_FDC_STATRegister &= (byte)~FDC_BUSY;
                    //else                                            // reading or writing - see if this is just a crc check?
                    //{
                    //    if (++m_statusReadsWithoutDataRegisterAccess > (m_nBytesToTransfer * 2))
                    //    {
                    //        m_FDC_STATRegister &= (byte)~FDC_BUSY;     // clear BUSY if data not read
                    //        ClearInterrupt();
                    //        //Program.pStaticFloppyActivityLight[nDrive]->SetBitmap (Program.m_hGreyDot);
                    //    }
                    //}

                    if ((m_statusReadsWithoutDataRegisterAccess >= (m_nBytesToTransfer / 16)) && (m_nBytesToTransfer > 0) && m_nFDCReading)
                    {
                        m_FDC_STATRegister &= (byte)~FDC_BUSY;     // clear BUSY if data not read
                        ClearInterrupt();
                    }

                    d = m_FDC_STATRegister;                      // get controller status
                    break;
                case (int)FDCRegisterOffsets.FDC_DRVREG_OFFSET:
                    LogActivity(4, "    register = FDC_DRVREG_OFFSET\n");
                    d = (byte)(m_FDC_DRVRegister | 0x40);
                    break;
                case (int)FDCRegisterOffsets.FDC_TRKREG_OFFSET:
                    LogActivity(4, "    register = FDC_TRKREG_OFFSET\n");
                    d = m_FDC_TRKRegister;                      // get Track Register
                    break;
                case (int)FDCRegisterOffsets.FDC_SECREG_OFFSET:
                    LogActivity(4, "    register = FDC_SECREG_OFFSET\n");      // there is no read on sector register - just return track register
                    d = m_FDC_TRKRegister;                      // get Track Register
                    break;
                default:
                    LogActivity(4, "    register = MEMORY - invalid register\n");
                    d = Program._cpu.ReadFromFirst64K(m);   // memory read
                    break;
            }

            if (fsLog != null)
            {
                LogActivity(4, string.Format("    value returned = {0}\n", d.ToString("X2")));
            }

            return (d);
        }

        public override void Init(int nWhichController, byte[] sMemoryBase, ushort sBaseAddress, int nRow, bool bInterruptEnabled)
        {
            m_nRow = nRow;
            base.Init (nWhichController, sMemoryBase, sBaseAddress, nRow, bInterruptEnabled);
        }

        //void Configure (CString strBoardName, int nBaseAddress, char *szBaseAddress, int sizeofBaseAddress)
        //{
        //    int nReturn;
        //    CConfigFDC pDlg;

        //    pDlg.m_sAddress  = nBaseAddress;
        //    pDlg.m_nFlag     = _bInterruptEnabled;
    
        //    nReturn = pDlg.DoModal ();

        //    if (nReturn == IDOK)
        //    {
        //        sprintf_s (szBaseAddress, sizeofBaseAddress, "0x%04X", pDlg.m_sAddress);
        //        _bInterruptEnabled = pDlg.m_nFlag;
        //    }
        //}
    }
}
